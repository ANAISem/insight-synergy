import React, { useState, useEffect, useRef } from 'react';
import { 
  Box, 
  Typography, 
  TextField, 
  Button, 
  Paper, 
  Stack, 
  CircularProgress,
  Alert,
  Chip,
  Grid,
  Avatar,
  Card,
  CardContent,
  CardHeader,
  Divider,
  IconButton,
  LinearProgress,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Tab,
  Tabs,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  FormControlLabel,
  Switch
} from '@mui/material';
import { 
  Person as PersonIcon,
  Science as ScienceIcon,
  Send as SendIcon,
  Add as AddIcon,
  Remove as RemoveIcon,
  Forum as ForumIcon,
  CheckCircle as CheckCircleIcon,
  Info as InfoIcon,
  ExpandMore as ExpandMoreIcon,
  Lightbulb as LightbulbIcon,
  Psychology as PsychologyIcon,
  VerifiedUser as VerifiedUserIcon,
  Warning as WarningIcon,
  ArrowForward as ArrowForwardIcon,
  FactCheck as FactCheckIcon,
  Settings as SettingsIcon,
  Refresh as RefreshIcon,
  ArrowDownward as ArrowDownwardIcon,
  PlayArrow as PlayArrowIcon,
  Pause as PauseIcon,
  Check as CheckIcon
} from '@mui/icons-material';

interface LiveExpertDebatePanelProps {
  apiUrl: string;
  isConnected: boolean;
  projectId?: string;
}

interface Expert {
  id: string;
  name: string;
  domain: string;
  specialty: string;
  background: string;
  perspective: string;
  avatar: string;
  color?: string;
  expertise?: number;
  validatedCredentials?: boolean;
}

interface Message {
  id: string;
  expertId: string;
  expertName: string;
  avatar: string;
  content: string;
  timestamp: string;
  references?: string[];
  factChecked?: boolean;
  factCheckResult?: FactCheckResult;
  isLoading?: boolean;
  expertAvatar?: string;
  expertColor?: string;
}

interface FactCheckResult {
  isFactual: boolean;
  confidence: number;
  sources?: {
    title: string;
    url: string;
    reliability?: number;
  }[];
  corrections?: string[];
}

interface Insight {
  id: string;
  title: string;
  description: string;
  expert: string;
  confidence: number;
  tags?: string[];
}

interface DebateTarget {
  topic: string;
  goals: string[];
  completedGoals: string[];
  context?: string;
}

interface CognitiveAnalysis {
  patternDetected?: string;
  biasDetected?: string;
  suggestionForImprovement?: string;
  adaptedResponseStyle?: string;
}

// Neue Komponente, die das bestehende ExpertDebatePanel erweitert
const LiveExpertDebatePanel: React.FC<LiveExpertDebatePanelProps> = ({ apiUrl, isConnected, projectId }) => {
  // Zustandsverwaltung f√ºr Experten
  const [experts, setExperts] = useState<Expert[]>([]);
  const [selectedExperts, setSelectedExperts] = useState<Expert[]>([]);
  const [isLoadingExperts, setIsLoadingExperts] = useState(false);
  
  // Zustandsverwaltung f√ºr die Debatte
  const [topic, setTopic] = useState('');
  const [context, setContext] = useState('');
  const [userMessage, setUserMessage] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [insights, setInsights] = useState<Insight[]>([]);
  const [isGeneratingDebate, setIsGeneratingDebate] = useState(false);
  
  // Zielmanagement und Fortschritt
  const [debateTargets, setDebateTargets] = useState<DebateTarget | null>(null);
  const [showTargets, setShowTargets] = useState(true);
  
  // Cognitive Loop Integration
  const [cognitiveAnalysis, setCognitiveAnalysis] = useState<CognitiveAnalysis | null>(null);
  const [factCheckingEnabled, setFactCheckingEnabled] = useState(true);
  
  // Fehlerbehandlung
  const [error, setError] = useState<string | null>(null);
  
  // UI-Steuerung
  const [activeTab, setActiveTab] = useState(0);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const [autoScroll, setAutoScroll] = useState(true);
  const [showScrollButton, setShowScrollButton] = useState(false);
  const [newMessageCount, setNewMessageCount] = useState(0);
  // Neue Zustandsvariablen f√ºr Pause-Funktion
  const [isPaused, setIsPaused] = useState(false);
  const [discussionTimer, setDiscussionTimer] = useState<NodeJS.Timeout | null>(null);  // Neue Zustandsvariablen f√ºr Pause-Funktion
  const [isPaused, setIsPaused] = useState(false);
  const [discussionTimer, setDiscussionTimer] = useState<NodeJS.Timeout | null>(null);
  // Neue Zustandsvariable f√ºr Pause-Funktion
  const [isPaused, setIsPaused] = useState(false);
  // Timer f√ºr automatische Diskussionen
  const [discussionTimer, setDiscussionTimer] = useState<NodeJS.Timeout | null>(null);
  
  // Lade Experten beim ersten Laden der Komponente
  useEffect(() => {
    if (isConnected) {
      loadExperts();
    }
  }, [isConnected]);
  
  // Scroll zum Ende der Nachrichten, wenn neue hinzukommen
  useEffect(() => {
    if (messagesEndRef.current && autoScroll) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      setNewMessageCount(0);
    } else if (!autoScroll && messages.length > 0) {
      // Wenn automatisches Scrollen deaktiviert ist, erh√∂he den Z√§hler f√ºr neue Nachrichten
      // Aber nur wenn wirklich eine neue Nachricht hinzugekommen ist (nicht bei jedem Rendering)
      const chatContainer = chatContainerRef.current;
      if (chatContainer) {
        const { scrollTop, scrollHeight, clientHeight } = chatContainer;
        const isAtBottom = scrollHeight - scrollTop - clientHeight < 50;
        
        if (!isAtBottom) {
          setNewMessageCount(prev => prev + 1);
        }
      }
    }
  }, [messages.length]);

  // √úberwache Scroll-Position, um den Scroll-Button anzuzeigen
  useEffect(() => {
    const chatContainer = chatContainerRef.current;
    if (!chatContainer) return;

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = chatContainer;
      // Zeige den Button, wenn nicht am Ende des Chats
      const isAtBottom = scrollHeight - scrollTop - clientHeight < 50;
      setShowScrollButton(!isAtBottom);
      
      // Wenn der Benutzer manuell zum Ende scrollt, setze den Z√§hler zur√ºck
      if (isAtBottom) {
        setNewMessageCount(0);
      }
    };

    chatContainer.addEventListener('scroll', handleScroll);
    return () => {
      chatContainer.removeEventListener('scroll', handleScroll);
    };
  }, []);

  // Funktion zum Scrollen zum Ende
  const scrollToBottom = () => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      setNewMessageCount(0);
    }
  };
  
  // Hauptfunktionen werden hier implementiert...
  
  // Experten laden
  const loadExperts = async (domain?: string) => {
    setIsLoadingExperts(true);
    setError(null);

    try {
      // Versuche, die Experten √ºber die API zu laden
      console.log(`Versuche, Experten √ºber API zu laden: ${apiUrl}/cognitive/profiles`);
      const response = await fetch(`${apiUrl}/cognitive/profiles`);
      
      if (!response.ok) {
        throw new Error(`HTTP-Fehler: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.experts) {
        setExperts(data.experts);
        console.log("Experten √ºber API geladen:", data.experts.length);
      } else {
        throw new Error('Unerwartetes Format der API-Antwort');
      }
    } catch (err: any) {
      console.error('Fehler beim Laden der Experten √ºber API:', err);
      console.log('Verwende lokale Beispiel-Experten als Fallback');
      
      // Beispiel-Experten generieren
        const sampleExperts: Expert[] = [
          {
            id: 'exp-001',
            name: 'Dr. Tech Visionary',
            domain: 'Technologie',
            specialty: 'KI-Entwicklung & Zukunftstechnologien',
            background: 'F√ºhrender Forscher im Bereich k√ºnstliche Intelligenz mit Schwerpunkt auf ethischen Implikationen.',
            perspective: 'Techno-optimistisch, aber mit kritischem Blick auf gesellschaftliche Auswirkungen',
          avatar: 'üß†',
          color: '#6366f1',
          expertise: 95,
          validatedCredentials: true
          },
          {
            id: 'exp-002',
            name: 'Prof. EcoThinker',
            domain: 'Umweltwissenschaften',
            specialty: 'Klimawandel & Nachhaltige Entwicklung',
            background: 'Langj√§hrige Forschung zu Umweltauswirkungen verschiedener Technologien und Wirtschaftsmodelle.',
            perspective: 'Fokus auf langfristige √∂kologische Nachhaltigkeit und Systemwandel',
          avatar: 'üåç',
          color: '#22c55e',
          expertise: 92,
          validatedCredentials: true
          },
          {
            id: 'exp-003',
            name: 'FinExpert',
            domain: 'Wirtschaft',
            specialty: 'Finanzmarkt & Investitionsanalyse',
            background: 'Jahrzehnte an Erfahrung in der Analyse globaler M√§rkte und wirtschaftlicher Trends.',
            perspective: 'Pragmatisch, datengetrieben mit Fokus auf wirtschaftlichen Mehrwert',
          avatar: 'üìä',
          color: '#eab308',
          expertise: 88,
          validatedCredentials: true
          },
          {
            id: 'exp-004',
            name: 'Ethics Specialist',
            domain: 'Philosophie & Ethik',
            specialty: 'Angewandte Ethik & soziale Gerechtigkeit',
            background: 'Forschung zu ethischen Fragen neuer Technologien und deren gesellschaftlichen Implikationen.',
            perspective: 'Stellt kritische Fragen zu Fairness, Zug√§nglichkeit und langfristigen Konsequenzen',
          avatar: '‚öñÔ∏è',
          color: '#8b5cf6',
          expertise: 90,
          validatedCredentials: true
          },
          {
            id: 'exp-005',
            name: 'Policy Advisor',
            domain: 'Politik & Regulierung',
            specialty: 'Internationale Richtlinien & Gesetzgebung',
            background: 'Beratung f√ºr Regierungen und internationale Organisationen zu Regulierungsfragen.',
            perspective: 'Fokus auf praktische Umsetzbarkeit und regulatorische Herausforderungen',
          avatar: 'üìù',
          color: '#0ea5e9',
          expertise: 87,
          validatedCredentials: true
        },
        {
          id: 'exp-006',
          name: 'Dr. Medicine Insights',
          domain: 'Medizin',
          specialty: 'Medizinische Ethik & Gesundheitssystemforschung',
          background: 'Forschung und Praxis an der Schnittstelle zwischen medizinischer Innovation und ethischen Fragen.',
          perspective: 'Patientenzentrierter Ansatz mit Fokus auf gerechten Zugang zu Gesundheitsversorgung',
          avatar: 'üè•',
          color: '#ec4899',
          expertise: 93,
          validatedCredentials: true
        },
        {
          id: 'exp-007',
          name: 'Tech Ethicist',
          domain: 'Technologieethik',
          specialty: 'KI-Ethik & Verantwortungsvolle Innovation',
          background: 'Forschung zur ethischen Entwicklung und Anwendung von KI in verschiedenen Bereichen.',
          perspective: 'Fokus auf menschenzentrierte Technologieentwicklung und ethische Leitplanken',
          avatar: 'ü§ñ',
          color: '#3b82f6',
          expertise: 96,
          validatedCredentials: true
        }
      ];
      
        setExperts(sampleExperts);
      console.log("Lokale Beispiel-Experten geladen:", sampleExperts.length);
    } finally {
      setIsLoadingExperts(false);
    }
  };

  // Expertenauswahl
  const toggleExpertSelection = (expert: Expert) => {
    setSelectedExperts(prevSelected => {
      const isSelected = prevSelected.some(e => e.id === expert.id);
      
      if (isSelected) {
        return prevSelected.filter(e => e.id !== expert.id);
      } else {
        // Maximum 5 Experten ausw√§hlen
        if (prevSelected.length >= 5) {
          setError('Sie k√∂nnen maximal 5 Experten f√ºr eine Debatte ausw√§hlen.');
          return prevSelected;
        }
        return [...prevSelected, expert];
      }
    });
  };

  // Pr√ºfen ob ein Experte ausgew√§hlt ist
  const isExpertSelected = (expertId: string): boolean => {
    return selectedExperts.some(expert => expert.id === expertId);
  };

  // Automatische Expertenauswahl basierend auf dem Thema
  const suggestExperts = async () => {
    if (!topic || topic.trim().length < 5) {
      setError('Bitte geben Sie zuerst ein Thema ein, um passende Experten vorzuschlagen.');
      return;
    }

    setIsLoadingExperts(true);
    setError(null);

    try {
      // In einer echten Implementierung w√ºrde hier ein API-Aufruf erfolgen
      // F√ºr diese Demo w√§hlen wir zuf√§llig 3 Experten aus
      const shuffled = [...experts].sort(() => 0.5 - Math.random());
      const suggested = shuffled.slice(0, 3);
      
      setSelectedExperts(suggested);
      
    } catch (err: any) {
      console.error('Fehler bei der Expertenvorschl√§gen:', err);
      setError('Die Experten konnten nicht automatisch ausgew√§hlt werden.');
    } finally {
      setIsLoadingExperts(false);
    }
  };

  // Generiere neue Experten basierend auf dem Thema
  const generateNewExpert = async () => {
    if (!topic || topic.trim().length < 5) {
      setError('Bitte geben Sie zuerst ein Thema ein, um einen relevanten Experten zu generieren.');
      return;
    }

    setIsLoadingExperts(true);
    setError(null);

    try {
      // In einer echten Implementierung w√ºrde hier ein API-Aufruf erfolgen
      // F√ºr diese Demo erstellen wir einen neuen Experten mit Dummy-Daten
      const newExpert: Expert = {
        id: `exp-${Date.now()}`,
        name: `Spezialist f√ºr ${topic}`,
        domain: 'Themenspezifisches Fachgebiet',
        specialty: `${topic} (automatisch generiert)`,
        background: `Ein speziell f√ºr das Thema "${topic}" generierter Experte mit umfassendem Fachwissen.`,
        perspective: 'Bietet eine ausgewogene, themenspezifische Perspektive mit tiefem Sachverst√§ndnis.',
        avatar: 'üîç'
      };
      
      setExperts(prev => [...prev, newExpert]);
      setSelectedExperts(prev => [...prev, newExpert]);
      
    } catch (err: any) {
      console.error('Fehler bei der Expertengenerierung:', err);
      setError('Es konnte kein neuer Experte generiert werden.');
    } finally {
      setIsLoadingExperts(false);
    }
  };

  // Startet die automatisierte Diskussion mit Ber√ºcksichtigung der Pause-Funktion
  const handleAutomatedDiscussion = (nextExpert: Expert, isFirstMessage: boolean, delay: number = 3000) => {
    // Wenn die Diskussion pausiert ist, wird keine neue Nachricht generiert
    if (isPaused) return;
    
    // Vorhandenen Timer l√∂schen, um doppelte Timer zu vermeiden
    if (discussionTimer) {
      clearTimeout(discussionTimer);
    }
    
    // Neuen Timer setzen
    const timer = setTimeout(() => {
      generateExpertMessage(nextExpert, isFirstMessage);
    }, delay);
    
    setDiscussionTimer(timer);
  };
  
  // Funktion zum Pausieren/Fortsetzen der Diskussion
  const togglePauseDiscussion = () => {
    setIsPaused(prev => !prev);
    
    // Wenn fortgesetzt wird und gen√ºgend Experten vorhanden sind, starte die Diskussion wieder
    if (isPaused && selectedExperts.length > 1) {
      const randomExpert = selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
      handleAutomatedDiscussion(randomExpert, false, 1500);
    }
  };

  // Generiere neue Debatte
  const startDebate = async () => {
    if (topic.trim().length < 5) {
      setError('Das Thema muss mindestens 5 Zeichen enthalten.');
      return;
    }

    if (selectedExperts.length < 2) {
      setError('Bitte w√§hlen Sie mindestens zwei Experten f√ºr die Debatte aus.');
      return;
    }

    setIsGeneratingDebate(true);
    setError(null);
    setMessages([]);
    setInsights([]);
    setIsPaused(false); // Reset der Pause-Funktion beim Start einer neuen Debatte    setIsPaused(false); // Reset der Pause-Funktion beim Start einer neuen Debatte
    setIsPaused(false); // Reset pause state when starting a new debate

    try {
      // Automatische Zielsetzung erstellen
      const goals = await generateDebateGoals(topic, context);
      
      setDebateTargets({
        topic,
        goals,
        completedGoals: [],
        context: context || undefined
      });

      // Begr√º√üungsnachricht f√ºr den Nutzer
      setMessages([
        {
          id: `msg-welcome-${Date.now()}`,
          expertId: 'system',
          expertName: 'Insight Synergy',
          avatar: 'üîç',
          content: `Willkommen zur Expertendebatte zum Thema "${topic}". Die ausgew√§hlten Experten werden nun verschiedene Perspektiven zu diesem Thema diskutieren. Sie k√∂nnen jederzeit Fragen stellen oder die Debatte in bestimmte Richtungen lenken.`,
          timestamp: new Date().toISOString()
        }
      ]);

      // Experten-Debatte starten
      setTimeout(() => {
        generateExpertMessage(selectedExperts[0], true);
      }, 1000);

    } catch (err: any) {
      console.error('Fehler bei der Generierung der Debatte:', err);
      setError(`Fehler bei der Debatte: ${err.message || 'Unbekannter Fehler'}`);
    } finally {
      setIsGeneratingDebate(false);
    }
  };

  // Automatisch Ziele f√ºr die Debatte generieren
  const generateDebateGoals = async (topic: string, context?: string): Promise<string[]> => {
    // Lokale Implementierung ohne API-Aufruf
    console.log(`Generiere Debattenziele f√ºr Thema: ${topic}`);
    
    // Grundlegende Ziele, die f√ºr die meisten Debatten relevant sind
    const commonGoals = [
      'Unterschiedliche Perspektiven zum Thema identifizieren',
      'Vor- und Nachteile der wichtigsten Ans√§tze diskutieren',
      'Gesellschaftliche Auswirkungen analysieren'
    ];
    
    // Themenspezifische Ziele basierend auf Schl√ºsselw√∂rtern im Thema
    const specificGoals: string[] = [];
    
    // Technologie-bezogene Ziele
    if (topic.toLowerCase().includes('ki') || 
        topic.toLowerCase().includes('technologie') || 
        topic.toLowerCase().includes('digital') ||
        topic.toLowerCase().includes('tech') ||
        topic.toLowerCase().includes('ai') ||
        topic.toLowerCase().includes('intelligence')) {
      specificGoals.push('Technologische Machbarkeit und Grenzen diskutieren');
      specificGoals.push('Datenschutz- und Sicherheitsaspekte betrachten');
      specificGoals.push('Zukunftsperspektiven und Entwicklungspotenziale aufzeigen');
    }
    
    // Ethik-bezogene Ziele
    if (topic.toLowerCase().includes('ethik') || 
        topic.toLowerCase().includes('moral') || 
        topic.toLowerCase().includes('recht') ||
        topic.toLowerCase().includes('verantwortung')) {
      specificGoals.push('Ethische Grundprinzipien und deren Anwendung diskutieren');
      specificGoals.push('Unterschiedliche moralische Perspektiven gegen√ºberstellen');
      specificGoals.push('Rechtliche und regulatorische Implikationen betrachten');
    }
    
    // Umwelt- und Nachhaltigkeitsziele
    if (topic.toLowerCase().includes('umwelt') || 
        topic.toLowerCase().includes('klima') || 
        topic.toLowerCase().includes('nachhaltig') ||
        topic.toLowerCase().includes('√∂kolog')) {
      specificGoals.push('√ñkologische Auswirkungen und Nachhaltigkeit diskutieren');
      specificGoals.push('Kurzfristige versus langfristige Umwelteffekte abw√§gen');
      specificGoals.push('Konkrete Handlungsempfehlungen f√ºr Umweltschutz erarbeiten');
    }
    
    // Wirtschaftliche Ziele
    if (topic.toLowerCase().includes('wirtschaft') || 
        topic.toLowerCase().includes('√∂konom') || 
        topic.toLowerCase().includes('finan') ||
        topic.toLowerCase().includes('markt')) {
      specificGoals.push('Wirtschaftliche Machbarkeit und Kosteneffizienz analysieren');
      specificGoals.push('Marktpotenziale und Gesch√§ftsmodelle diskutieren');
      specificGoals.push('Verteilungseffekte und wirtschaftliche Gerechtigkeit betrachten');
    }
    
    // Gesundheitsziele
    if (topic.toLowerCase().includes('gesundheit') || 
        topic.toLowerCase().includes('medizin') || 
        topic.toLowerCase().includes('patient') ||
        topic.toLowerCase().includes('therapie')) {
      specificGoals.push('Medizinische Vor- und Nachteile abw√§gen');
      specificGoals.push('Patientensicherheit und -rechte diskutieren');
      specificGoals.push('Zugang zu Gesundheitsleistungen und Gerechtigkeit analysieren');
    }
    
    // Allgemeine wichtige Ziele, die immer hinzugef√ºgt werden sollten
    specificGoals.push('Praktische Implementierungsstrategien betrachten');
    specificGoals.push('Ethische Implikationen ber√ºcksichtigen');
    
    // Kombiniere allgemeine und spezifische Ziele und w√§hle maximal 5 aus
    const allGoals = [...commonGoals, ...specificGoals];
    const shuffledGoals = allGoals.sort(() => Math.random() - 0.5);
    
    // Maximale Anzahl von 5 Zielen zur√ºckgeben
    return shuffledGoals.slice(0, 5);
  };

  // Debatte stoppen
  const stopDebate = () => {
    // F√ºge Systemnachricht hinzu, dass die Debatte gestoppt wurde
    const stopMessage: Message = {
      id: `msg-stop-${Date.now()}`,
      expertId: 'system',
      expertName: 'Insight Synergy',
      avatar: '‚èπÔ∏è',
      content: 'Die Debatte wurde auf Ihre Anfrage hin beendet. Sie k√∂nnen die gesammelten Erkenntnisse im Tab "Einsichten & Ergebnisse" einsehen oder eine neue Debatte starten.',
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, stopMessage]);
    
    // Hier w√ºrden in einer realen Implementierung alle laufenden API-Calls abgebrochen
    // und Timer gestoppt werden
    
    // Tab zu den Einsichten wechseln
    setTimeout(() => {
      setActiveTab(2);
    }, 2000);
  };

  // Debatte zur√ºcksetzen
  const resetDebate = () => {
    // Zur√ºck zur Debattenvorbereitung
    setMessages([]);
    setInsights([]);
    setIsPaused(false); // Reset der Pause-Funktion beim Start einer neuen Debatte    setIsPaused(false); // Reset der Pause-Funktion beim Start einer neuen Debatte
    setDebateTargets(null);
    setCognitiveAnalysis(null);
    setActiveTab(0);
  };

  // Nutzer-Nachricht senden
  const sendUserMessage = () => {
    if (!userMessage.trim()) return;
    
    const newMessage: Message = {
      id: `msg-user-${Date.now()}`,
      expertId: 'user',
      expertName: 'Sie',
      avatar: 'üë§',
      content: userMessage,
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, newMessage]);
    setUserMessage('');
    
    // Cognitive Loop f√ºr die Nutzerinteraktion aktivieren
    processCognitiveLoop(userMessage);
    
    // Antwort von einem zuf√§lligen Experten generieren
    setTimeout(() => {
      const randomExpert = selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
      generateExpertMessage(randomExpert, false);
  };

  // Experten-Nachricht generieren
  // Startet die automatisierte Diskussion mit Ber√ºcksichtigung der Pause-Funktion
  const handleAutomatedDiscussion = (nextExpert: Expert, isFirstMessage: boolean, delay: number = 3000) => {
    // Wenn die Diskussion pausiert ist, wird keine neue Nachricht generiert
    if (isPaused) return;

    // Vorhandenen Timer l√∂schen, um doppelte Timer zu vermeiden
    if (discussionTimer) {
      clearTimeout(discussionTimer);
    }

    // Neuen Timer setzen
    const timer = setTimeout(() => {
      generateExpertMessage(nextExpert, isFirstMessage);
    }, delay);

    setDiscussionTimer(timer);
  };

  // Startet die automatisierte Diskussion mit Ber√ºcksichtigung der Pause-Funktion
  const handleAutomatedDiscussion = (nextExpert: Expert, isFirstMessage: boolean, delay: number = 3000) => {
    // Wenn die Diskussion pausiert ist, wird keine neue Nachricht generiert
    if (isPaused) return;
    
    // Vorhandenen Timer l√∂schen, um doppelte Timer zu vermeiden
    if (discussionTimer) {
      clearTimeout(discussionTimer);
    }
    
    // Neuen Timer setzen
    const timer = setTimeout(() => {
      generateExpertMessage(nextExpert, isFirstMessage);
    }, delay);
    
    setDiscussionTimer(timer);
  };
  const generateExpertMessage = async (expert: Expert, isFirstMessage: boolean) => {
    setError(null);
    
    try {
      console.log(`Versuche, Expertenantwort √ºber API zu generieren: ${apiUrl}/live-expert-debate/message`);
      
      // Vorbereiten der vorherigen Nachrichten f√ºr den API-Aufruf
      const previousMessages = messages
        .filter(m => m.expertId !== 'system' && m.expertId !== expert.id)
          .map(m => ({
            expertId: m.expertId,
            expertName: m.expertName,
            content: m.content
        }));
      
      // API-Aufruf, um eine Expertenantwort zu generieren
      const response = await fetch(`${apiUrl}/live-expert-debate/message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic,
          context: context || undefined,
          expert: {
            id: expert.id,
            name: expert.name,
            domain: expert.domain,
            specialty: expert.specialty,
            background: expert.background || '',
            perspective: expert.perspective || ''
          },
          isFirstMessage,
          previousMessages,
          userMessage: messages.filter(m => m.expertId === 'user').pop()?.content
        }),
        signal: AbortSignal.timeout(20000)
      });

      if (!response.ok) {
        console.warn(`API-Fehler: ${response.status} ${response.statusText}`);
        throw new Error(`HTTP-Fehler: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      console.log("API-Antwort erhalten:", data);
      
      if (data.success && data.message) {
        console.log("Erfolgreiche API-Antwort mit Nachricht:", data.message);
        
        // Die generierte Nachricht zum State hinzuf√ºgen
      const newMessage: Message = {
          id: data.message.id || `msg-${expert.id}-${Date.now()}`,
        expertId: expert.id,
        expertName: expert.name,
        avatar: expert.avatar,
        content: data.message.content,
          timestamp: data.message.timestamp || new Date().toISOString(),
        references: data.message.references || []
      };
      
      setMessages(prev => [...prev, newMessage]);
      
      // Faktencheck ausf√ºhren, wenn aktiviert
      if (factCheckingEnabled) {
        performFactCheck(newMessage);
      }
      
      // Debattenziele aktualisieren
      updateDebateProgress();
      
      // Wenn es nicht die erste Nachricht ist, w√§hle einen anderen Experten f√ºr die n√§chste Nachricht
      if (!isFirstMessage && selectedExperts.length > 1) {
        // Alle Experten finden, die noch nicht zu oft geantwortet haben
        const eligibleExperts = selectedExperts.filter(e => 
          e.id !== expert.id && 
          messages.filter(m => m.expertId === e.id).length < 3
        );
        
        if (eligibleExperts.length > 0) {
          const nextExpert = eligibleExperts[Math.floor(Math.random() * eligibleExperts.length)];
          // Die automatisierte Diskussion starten, wenn nicht pausiert
          handleAutomatedDiscussion(nextExpert, false, 3000 + Math.random() * 2000);
        }
      }
    } catch (err: any) {
      console.error('Fehler bei der Generierung der Expertenantwort:', err);
      console.log('Verwende lokale Fallback-Implementierung');
      
      // Fallback zur lokalen Implementierung
      fallbackExpertMessage(expert, isFirstMessage);
    }
  };
  
  // Fallback-Funktion, wenn API-Anfrage fehlschl√§gt
  const fallbackExpertMessage = (expert: Expert, isFirstMessage: boolean) => {
    // Zeigt dem Benutzer, dass wir zur lokalen Fallback-L√∂sung wechseln
    const tempMessageId = `temp-${Date.now()}`;
    const tempMessage: Message = {
      id: tempMessageId,
      expertId: expert.id,
      expertName: expert.name,
      avatar: expert.avatar || 'üë§',
      content: 'Generiere Antwort...',
      timestamp: new Date().toISOString(),
      isLoading: true
    };
    
    setMessages(prevMessages => [...prevMessages, tempMessage]);
    
    // Verwende die vorhandene Simulation
    simulateAIExpertResponse(expert, isFirstMessage);
  };
  
  // Simuliert eine KI-generierte Expertenantwort mit einer verbesserten Fallback-Implementierung
  const simulateAIExpertResponse = (expert: Expert, isFirstMessage: boolean) => {
    // Zeige Ladeanimation, um Netzwerkanfrage zu simulieren
    // Dies gibt dem Benutzer das Gef√ºhl, dass tats√§chlich eine KI-Verarbeitung stattfindet
    const simulatedResponseDelay = 2000 + Math.random() * 3000; // 2-5 Sekunden
    
    setTimeout(() => {
      // Kontext f√ºr die Antwortgenerierung zusammenstellen
      const latestMessages = messages.slice(-5); // Letzten 5 Nachrichten f√ºr Kontext
      const latestUserMessage = messages.filter(m => m.expertId === 'user').pop()?.content;
      const otherExpertMessages = messages.filter(m => 
        m.expertId !== 'system' && 
        m.expertId !== 'user' && 
        m.expertId !== expert.id
      );
      const latestOtherExpertMessage = otherExpertMessages.length > 0 ? 
        otherExpertMessages[otherExpertMessages.length - 1] : null;
      
      // Antwortinhalt basierend auf Kontext und Expertenprofil generieren
    let content = '';
      
    if (isFirstMessage) {
        // Erste Nachricht des Experten zum Thema
        content = `Als Experte f√ºr ${expert.specialty} m√∂chte ich einige wichtige Perspektiven zum Thema "${topic}" einbringen:\n\n`;
        content += getThemeSpecificResponse(expert, topic);
        
        // H√§ufig verwendete Einleitungss√§tze von KI-Modellen simulieren
        if (Math.random() > 0.5) {
          content += `\n\nEs ist wichtig zu beachten, dass dieses Thema vielschichtig ist und verschiedene Faktoren ber√ºcksichtigt werden m√ºssen.`;
        }
      } 
      else if (latestUserMessage) {
        // Antwort auf eine Benutzerfrage
        content = `${generateOpeningPhrase()} ${latestUserMessage} ${generateTransitionPhrase()}\n\n`;
        content += getThemeSpecificResponse(expert, latestUserMessage);
        
        // Abrunden mit einer Schlussfolgerung oder Frage
        if (Math.random() > 0.7) {
          content += `\n\nWas denken Sie √ºber diesen Aspekt? Gibt es bestimmte Bereiche, die Sie n√§her beleuchten m√∂chten?`;
        }
      }
      else if (latestOtherExpertMessage) {
        // Antwort auf einen anderen Experten
        content = `${generateAgreementOrDisagreementPhrase()} ${latestOtherExpertMessage.expertName} ${generatePerspectiveTransition()}\n\n`;
        content += getThemeSpecificResponse(expert, latestOtherExpertMessage.content);
        
        // Expertise-spezifische Erg√§nzung
        content += `\n\nAus der Perspektive der ${expert.domain} sollten wir auch bedenken, dass ${generateDomainSpecificInsight(expert.domain)}.`;
      } 
      else {
        // Generischer Beitrag zur Debatte
        content = `Zum Thema "${topic}" m√∂chte ich aus der Perspektive von ${expert.domain} folgende Punkte einbringen:\n\n`;
        content += getThemeSpecificResponse(expert, topic);
      }
      
      // Finde die tempor√§re Nachricht und ersetze sie durch die generierte Antwort
      setMessages(prevMessages => {
        const updatedMessages = [...prevMessages];
        const tempMessageIndex = updatedMessages.findIndex(
          m => m.isLoading && m.expertId === expert.id
        );
        
        if (tempMessageIndex !== -1) {
          // Ersetze die tempor√§re Nachricht
          updatedMessages[tempMessageIndex] = {
            ...updatedMessages[tempMessageIndex],
            content: content,
            isLoading: false,
            timestamp: new Date().toISOString()
          };
        } else {
          // Falls keine tempor√§re Nachricht gefunden wurde, f√ºge eine neue hinzu
          updatedMessages.push({
            id: `msg-${Date.now()}`,
      expertId: expert.id,
      expertName: expert.name,
            avatar: expert.avatar || 'üë§',
            content: content,
            timestamp: new Date().toISOString()
          });
        }
        
        return updatedMessages;
      });
      
      // Scrolle zum Ende der Nachrichtenliste
      if (messagesEndRef.current) {
        messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
      
      // Starte nach einer Pause eine Antwort vom n√§chsten Experten
      if (selectedExperts.length > 1 && Math.random() > 0.5) {
        // W√§hle einen anderen Experten
        const otherExperts = selectedExperts.filter(e => e.id !== expert.id);
        const nextExpert = otherExperts[Math.floor(Math.random() * otherExperts.length)];
        // Die automatisierte Diskussion starten, wenn nicht pausiert
        handleAutomatedDiscussion(nextExpert, false, 2000 + Math.random() * 8000);
      }
    }, simulatedResponseDelay);
  };
  
  // Hilfsfunktionen f√ºr die AI-Simulation
  const generateOpeningPhrase = () => {
    const phrases = [
      "Ihre Frage zu",
      "Bez√ºglich Ihrer Nachricht √ºber",
      "Zu Ihrem Punkt √ºber",
      "In Bezug auf Ihre Frage zu",
      "Wenn wir Ihren Gedanken zu",
      "Ihre √úberlegungen zu"
    ];
    return phrases[Math.floor(Math.random() * phrases.length)];
  };
  
  const generateTransitionPhrase = () => {
    const phrases = [
      "ist ein wichtiger Aspekt, den ich gerne n√§her beleuchten m√∂chte.",
      "m√∂chte ich einige differenzierte √úberlegungen einbringen.",
      "l√§sst sich aus meiner fachlichen Perspektive wie folgt betrachten:",
      "greift einen zentralen Punkt auf, den ich erg√§nzen m√∂chte.",
      "erlaubt mir, einige weitere Aspekte zu beleuchten."
    ];
    return phrases[Math.floor(Math.random() * phrases.length)];
  };
  
  const generateAgreementOrDisagreementPhrase = () => {
    const agreementPhrases = [
      "Ich stimme",
      "Ich teile die Sichtweise von",
      "In Erg√§nzung zu",
      "Aufbauend auf dem Punkt von",
      "In √úbereinstimmung mit"
    ];
    
    const disagreementPhrases = [
      "W√§hrend ich die √úberlegungen von",
      "Aus einer anderen Perspektive als",
      "Im Kontrast zur Darstellung von",
      "Ich sehe einen anderen Aspekt als",
      "Ich m√∂chte den Standpunkt von"
    ];
    
    const isAgreement = Math.random() > 0.4; // 60% Wahrscheinlichkeit f√ºr Zustimmung
    const phrases = isAgreement ? agreementPhrases : disagreementPhrases;
    return phrases[Math.floor(Math.random() * phrases.length)];
  };
  
  const generatePerspectiveTransition = () => {
    const agreementTransitions = [
      "und m√∂chte diesen Gedanken noch weiter ausf√ºhren.",
      "zu, w√ºrde jedoch gerne noch einen weiteren Aspekt hinzuf√ºgen.",
      "und sehe zus√§tzlich folgende Implikationen.",
      "voll und ganz, m√∂chte aber noch auf folgende Punkte hinweisen."
    ];
    
    const disagreementTransitions = [
      "respektiere, sehe ich die Situation aus einem anderen Blickwinkel.",
      "nachvollziehen kann, gibt es wichtige gegens√§tzliche Erkenntnisse zu beachten.",
      "verstehe, zeigt meine Expertise in diesem Bereich ein differenzierteres Bild.",
      "zu sch√§tzen wei√ü, sollten wir auch folgendes bedenken."
    ];
    
    const isAgreement = Math.random() > 0.4; // 60% Wahrscheinlichkeit f√ºr Zustimmung
    const transitions = isAgreement ? agreementTransitions : disagreementTransitions;
    return transitions[Math.floor(Math.random() * transitions.length)];
  };
  
  const generateDomainSpecificInsight = (domain: string) => {
    const insights = {
      "Technologie": [
        "die technologische Entwicklung einem nicht-linearen Pfad folgt und Prognosen oft die gesellschaftliche Anpassungsf√§higkeit untersch√§tzen",
        "Skalierbarkeit und Benutzerfreundlichkeit oft wichtiger sind als technische Perfektion",
        "der Erfolg einer Technologie stark von ihrer Integration in bestehende Systeme abh√§ngt"
      ],
      "Umweltwissenschaften": [
        "√∂kologische Systeme hochkomplex sind und Eingriffe oft unbeabsichtigte Nebenwirkungen haben k√∂nnen",
        "Nachhaltigkeitskonzepte immer im Kontext lokaler √ñkosysteme betrachtet werden m√ºssen",
        "langfristiger Umweltschutz und wirtschaftliches Wachstum sich nicht ausschlie√üen m√ºssen"
      ],
      "Wirtschaft": [
        "Marktdynamiken stark von regulatorischen Rahmenbedingungen und geopolitischen Faktoren beeinflusst werden",
        "erfolgreiche Gesch√§ftsmodelle eine Balance zwischen Innovation und Risikomanagement finden m√ºssen",
        "wirtschaftliche Prognosen immer unter Ber√ºcksichtigung sozialer und politischer Faktoren erfolgen sollten"
      ],
      "Philosophie & Ethik": [
        "ethische Prinzipien kulturell gepr√§gt sind und kontextabh√§ngig betrachtet werden m√ºssen",
        "technologischer Fortschritt immer auch ethische Fragen aufwirft, die nicht allein durch die Technik selbst gel√∂st werden k√∂nnen",
        "die Frage nach Verantwortung in komplexen Systemen zunehmend schwieriger zu beantworten ist"
      ],
      "Politik & Regulierung": [
        "erfolgreiche Regulierung einen ausgewogenen Ansatz zwischen Innovation und Schutz erfordert",
        "internationale Kooperation f√ºr die Bew√§ltigung globaler Herausforderungen unerl√§sslich ist",
        "gesellschaftliche Akzeptanz eine wesentliche Voraussetzung f√ºr die erfolgreiche Umsetzung von Policies ist"
      ],
      "Medizin": [
        "individuelle Gesundheitsfaktoren und genetische Pr√§dispositionen zunehmend an Bedeutung gewinnen",
        "Digitalisierung das Potenzial hat, den Zugang zu medizinischer Versorgung grundlegend zu demokratisieren",
        "psychische Gesundheit als integraler Bestandteil des Gesundheitssystems betrachtet werden muss"
      ],
      "Technologieethik": [
        "ethische Leitplanken f√ºr KI-Systeme bereits in der Designphase implementiert werden m√ºssen",
        "Transparenz und Erkl√§rbarkeit Grundvoraussetzungen f√ºr vertrauensw√ºrdige technologische Systeme sind",
        "die Frage der Datenhoheit und -souver√§nit√§t zunehmend zu einer gesellschaftlichen Schl√ºsselfrage wird"
      ]
    };
    
    // Default f√ºr unbekannte Dom√§nen
    const domainInsights = insights[domain as keyof typeof insights] || [
      "verschiedene Faktoren in Wechselwirkung stehen und ganzheitlich betrachtet werden m√ºssen",
      "ein multidisziplin√§rer Ansatz oft die besten Ergebnisse liefert",
      "langfristige Perspektiven manchmal kurzfristigen Gewinnen vorgezogen werden sollten"
    ];
    
    return domainInsights[Math.floor(Math.random() * domainInsights.length)];
  };

  // Faktencheck ausf√ºhren
  const performFactCheck = async (message: Message) => {
    try {
      // Faktencheck √ºber API durchf√ºhren
      const response = await fetch(`${apiUrl}/live-expert-debate/fact-check`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messageId: message.id,
          expertId: message.expertId,
          content: message.content,
          topic: topic,
          context: context || undefined
        }),
        signal: AbortSignal.timeout(15000)
      });

      if (!response.ok) {
        throw new Error(`HTTP-Fehler: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.success && data.factCheck) {
        // Nachricht mit Faktencheck aktualisieren
        setMessages(prev => 
          prev.map(msg => 
            msg.id === message.id 
              ? { ...msg, factChecked: true, factCheckResult: data.factCheck } 
              : msg
          )
        );
      } else {
        throw new Error('Unerwartetes Format der API-Antwort');
      }
    } catch (err: any) {
      console.error('Fehler beim Faktencheck:', err);
      // Fallback: Simulierter Faktencheck
      fallbackFactCheck(message);
    }
  };
  
  // Fallback f√ºr Faktencheck wenn API nicht verf√ºgbar
  const fallbackFactCheck = (message: Message) => {
    setTimeout(() => {
      const factCheckResult: FactCheckResult = {
        isFactual: Math.random() > 0.3, // 70% Wahrscheinlichkeit, dass die Fakten korrekt sind
        confidence: Math.random() * 0.4 + 0.6, // Confidence zwischen 0.6 und 1.0
        sources: [
          {
            title: 'Journal of Advanced Research',
            url: 'https://example.com/research',
            reliability: 0.92
          },
          {
            title: 'International Policy Institute',
            url: 'https://example.com/policy',
            reliability: 0.85
          }
        ]
      };
      
      // Bei Faktenproblemen Korrekturen hinzuf√ºgen
      if (!factCheckResult.isFactual) {
        factCheckResult.corrections = [
          'Eine genauere Formulierung w√§re: Die Studienergebnisse deuten auf einen Zusammenhang hin, beweisen diesen aber nicht endg√ºltig.',
          'Aktuelle Daten zeigen abweichende Trends in verschiedenen Regionen.'
        ];
      }
      
      // Nachricht mit Faktencheck aktualisieren
      setMessages(prev => 
        prev.map(msg => 
          msg.id === message.id 
            ? { ...msg, factChecked: true, factCheckResult } 
            : msg
        )
      );
    }, 2000); // Verz√∂gerung f√ºr realistischen Faktencheck-Prozess
  };

  // Cognitive Loop f√ºr adaptive Gespr√§chsf√ºhrung
  const processCognitiveLoop = async (userInput: string) => {
    try {
      // Cognitive Loop √ºber API abfragen
      const response = await fetch(`${apiUrl}/live-expert-debate/cognitive-analysis`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userInput,
          topic,
          context: context || undefined,
                    {/* Steuerelemente f√ºr Chat-Funktionen */}
                    <Box sx={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center', 
                      mb: 2,
                      px: 1,
                      py: 0.5,
                      borderRadius: 1,
                      bgcolor: 'rgba(0, 0, 0, 0.03)'
                    }}>
                      {/* Pause/Fortsetzen-Button */}
                      <Tooltip title={isPaused ? "Diskussion fortsetzen" : "Diskussion pausieren"}>
                        <Button
                          size="small"
                          variant="outlined"
                          color={isPaused ? "primary" : "secondary"}
                          onClick={() => setIsPaused(!isPaused)}
                          startIcon={isPaused ? <PlayArrowIcon /> : <PauseIcon />}
                        >
                          {isPaused ? "Fortsetzen" : "Pausieren"}
                        </Button>
                      </Tooltip>
                      
                      {/* Auto-Scroll-Toggle */}
                      <FormControlLabel
                        control={
                          <Switch 
                            checked={autoScroll}
                            onChange={(e) => setAutoScroll(e.target.checked)}
                            size="small"
                            color="primary"
                          />
                        }
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body2">Auto-Scroll</Typography>
                            {autoScroll && <CheckCircleIcon fontSize="small" color="success" sx={{ ml: 0.5 }} />}
                          </Box>
                        }
                      />
                    </Box>
          messageHistory: messages.map(m => ({
            id: m.id,
            expertId: m.expertId,
            expertName: m.expertName,
            content: m.content
          }))
        }),
        signal: AbortSignal.timeout(10000)
      });

      if (!response.ok) {
        throw new Error(`HTTP-Fehler: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.success && data.analysis) {
        setCognitiveAnalysis(data.analysis);
        
        // Bei erkanntem Bias eine entsprechende Modifikation der Debatte durchf√ºhren
        if (data.analysis.biasDetected) {
          // W√§hle einen Experten mit gegens√§tzlicher Perspektive basierend auf der API-Empfehlung
          const suggestedExpertId = data.analysis.suggestedExpertId;
          const counterPerspectiveExpert = selectedExperts.find(expert => expert.id === suggestedExpertId) || 
                                         selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
          
          setTimeout(() => {
            generateExpertMessage(counterPerspectiveExpert, false);
          }, 1000);
        }
        
        // Antwort von einem Experten generieren, der am besten auf den Benutzerkontext eingehen kann
        let randomExpert = selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
        if (data.analysis.recommendedExpertId) {
          const recommendedExpert = selectedExperts.find(e => e.id === data.analysis.recommendedExpertId);
          if (recommendedExpert) {
            randomExpert = recommendedExpert;
          }
        }
        
        setTimeout(() => {
          generateExpertMessage(randomExpert, false);
      } else {
        throw new Error('Unerwartetes Format der API-Antwort');
      }
    } catch (err: any) {
      console.error('Fehler bei der Cognitive Loop-Analyse:', err);
      // Fallback: Statische Cognitive Loop-Simulation
      fallbackCognitiveLoop(userInput);
    }
  };
  
  // Fallback f√ºr Cognitive Loop wenn API nicht verf√ºgbar
  const fallbackCognitiveLoop = (userInput: string) => {
    setTimeout(() => {
      // Analyse des Nutzerinputs und Reaktion des Systems
      const analysis: CognitiveAnalysis = {
        patternDetected: Math.random() > 0.5 ? 'Analytisches Denken' : 'Kreatives Denkmuster',
        biasDetected: Math.random() > 0.7 ? 'Best√§tigungstendenz erkannt' : undefined,
        suggestionForImprovement: 'Experten mit gegens√§tzlichen Perspektiven einbeziehen',
        adaptedResponseStyle: Math.random() > 0.5 ? 'Detaillierter, sachlicher Stil' : 'Explorativer, fragender Stil'
      };
      
      setCognitiveAnalysis(analysis);
      
      // Bei erkanntem Bias eine entsprechende Modifikation der Debatte durchf√ºhren
      if (analysis.biasDetected) {
        // W√§hle einen Experten mit gegens√§tzlicher Perspektive f√ºr die n√§chste Antwort
        const counterPerspectiveExpert = selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
        
        setTimeout(() => {
          generateExpertMessage(counterPerspectiveExpert, false);
        }, 1000);
      } else {
        // Antwort von einem zuf√§lligen Experten generieren
        setTimeout(() => {
          const randomExpert = selectedExperts[Math.floor(Math.random() * selectedExperts.length)];
          generateExpertMessage(randomExpert, false);
      }
    }, 1000);
  };

  // Einsicht generieren
  const generateInsight = async () => {
    try {
      // Einsicht √ºber API generieren
      const response = await fetch(`${apiUrl}/live-expert-debate/insight`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic,
          context: context || undefined,
          messageHistory: messages.map(m => ({
            expertId: m.expertId,
            expertName: m.expertName,
            content: m.content
          }))
        }),
        signal: AbortSignal.timeout(15000)
      });

      if (!response.ok) {
        throw new Error(`HTTP-Fehler: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.success && data.insight) {
        setInsights(prev => [...prev, data.insight]);
      } else {
        throw new Error('Unerwartetes Format der API-Antwort');
      }
    } catch (err: any) {
      console.error('Fehler bei der Einsichtsgenerierung:', err);
      // Fallback: Statische Einsicht generieren
      fallbackInsightGeneration();
    }
  };
  
  // Fallback f√ºr die Einsichtsgenerierung
  const fallbackInsightGeneration = () => {
    const insightTitles = [
      'Interessenkonflikte identifiziert',
      'Interdisziplin√§re L√∂sung m√∂glich',
      'Unerwartete Korrelation gefunden',
      'Ethische Herausforderungen erkannt',
      'Zuk√ºnftige Forschungsfragen'
    ];
    
    const newInsight: Insight = {
      id: `insight-${Date.now()}`,
      title: insightTitles[Math.floor(Math.random() * insightTitles.length)],
      description: `In der Debatte wurde ein wichtiger Zusammenhang zwischen verschiedenen Aspekten des Themas "${topic}" herausgearbeitet. Diese Erkenntnis k√∂nnte zu neuen L√∂sungsans√§tzen f√ºhren.`,
      expert: selectedExperts[Math.floor(Math.random() * selectedExperts.length)].name,
      confidence: Math.random() * 0.3 + 0.7, // Confidence zwischen 0.7 und 1.0
      tags: ['Haupterkenntnis', 'Vertiefungsw√ºrdig', topic]
    };
    
    setInsights(prev => [...prev, newInsight]);
  };

  // Debattenfortschritt aktualisieren
  const updateDebateProgress = () => {
    if (!debateTargets) return;
    
    // In einer echten Implementierung w√ºrde hier die KI den Fortschritt analysieren
    // F√ºr die Demo markieren wir zuf√§llig Ziele als erledigt
    
    const completedGoalIndex = debateTargets.goals.findIndex(
      goal => !debateTargets.completedGoals.includes(goal) && Math.random() > 0.7
    );
    
    if (completedGoalIndex >= 0) {
      const completedGoal = debateTargets.goals[completedGoalIndex];
      
      setDebateTargets(prev => {
        if (!prev) return prev;
        return {
          ...prev,
          completedGoals: [...prev.completedGoals, completedGoal]
        };
      });
    }
  };

  // Zuf√§llige Referenzen generieren
  const generateRandomReferences = (): string[] => {
    if (Math.random() > 0.7) return []; // 30% Chance, keine Referenzen zu haben
    
    const possibleReferences = [
      'Smith et al., 2022: "Advances in the Field"',
      'Journal of Modern Research, Vol. 12',
      'International Policy Framework, 2023',
      'Global Economic Review, Q2 2023',
      'Technical Analysis Report, Tech Institute'
    ];
    
    const numberOfReferences = Math.floor(Math.random() * 3) + 1; // 1-3 Referenzen
    const shuffled = [...possibleReferences].sort(() => 0.5 - Math.random());
    
    return shuffled.slice(0, numberOfReferences);
  };

  // Experten-Antwort-Templates nach Themengebieten
  const getThemeSpecificResponse = (expert: Expert, topic: string): string => {
    // KI und Technologie
    if (topic.toLowerCase().includes('ki') || 
        topic.toLowerCase().includes('ai') || 
        topic.toLowerCase().includes('tech') ||
        topic.toLowerCase().includes('intelligence') ||
        topic.toLowerCase().includes('open ai')) {
      
      if (expert.domain === 'Technologie') {
        return `Die KI-Landschaft entwickelt sich rasant. Als n√§chstes erwarte ich eine st√§rkere Fokussierung auf multimodale Modelle, die Text, Bild, Audio und Video nahtlos integrieren k√∂nnen. OpenAI und andere Marktf√ºhrer investieren stark in diese Richtung. 

F√ºr Insight Synergy sehe ich die Chance in der Spezialisierung und Nischenexzellenz. Statt direkt mit OpenAI zu konkurrieren, sollte sich Insight Synergy auf hochspezialisierte Anwendungen konzentrieren, wo Fachwissen und ma√ügeschneiderte L√∂sungen wichtiger sind als pure Modellgr√∂√üe.`;
      }
      
      if (expert.domain === 'Wirtschaft') {
        return `Aus wirtschaftlicher Sicht sehen wir einen Markt, der sich konsolidiert. OpenAI, Anthropic und andere gro√üe Player haben Milliarden an Investitionen erhalten. Der Wettbewerb wird sich auf spezifische Branchen und Anwendungsf√§lle verlagern.

Insight Synergy kann in diesem Umfeld durch strategische Partnerschaften und fokussierte Marktsegmentierung √ºberleben und wachsen. Die wirtschaftlichen Vorteile liegen in der Spezialisierung und in der Integration bestehender KI-Modelle, statt sie vollst√§ndig neu zu entwickeln.`;
      }
      
      if (expert.domain === 'Philosophie & Ethik' || expert.domain.includes('Ethik')) {
        return `Die ethischen Herausforderungen werden mit fortschreitender KI-Entwicklung zunehmen. Fragen der Transparenz, Verantwortlichkeit und des verantwortungsvollen Einsatzes werden wichtiger denn je.

Insight Synergy hat hier die Chance, ethische √úberlegungen von Anfang an in seine Produkte zu integrieren. Ein transparenter, ethischer Ansatz kann ein entscheidender Wettbewerbsvorteil sein, besonders wenn gr√∂√üere Unternehmen in diesem Bereich Defizite aufweisen.`;
      }
      
      if (expert.domain.includes('Umwelt')) {
        return `Die Umweltauswirkungen gro√üer KI-Modelle sind erheblich - von Energieverbrauch bis zur Ressourcennutzung. Die n√§chste Generation der KI-Entwicklung muss √∂kologisch nachhaltiger werden.

Insight Synergy k√∂nnte sich als umweltbewusste Alternative positionieren, mit energieeffizienteren Modellen und klimaneutralen Rechenzentren. Nachhaltigkeit ist nicht nur ethisch richtig, sondern wird zunehmend auch ein wirtschaftlicher Faktor.`;
      }
      
      if (expert.domain.includes('Medizin') || expert.domain.includes('Gesundheit')) {
        return `Im Gesundheitsbereich sehen wir enormes Potenzial f√ºr KI-Anwendungen, aber auch komplexe Anforderungen an Datenschutz, Genauigkeit und ethische Standards. 

Insight Synergy k√∂nnte sich auf medizinische KI-Anwendungen spezialisieren, wo pr√§zise, zuverl√§ssige und ethisch vertretbare L√∂sungen gefragt sind. Hier ist nicht die Gr√∂√üe des Modells entscheidend, sondern die Qualit√§t der Daten und das Verst√§ndnis medizinischer Kontexte.`;
      }
      
      // Default f√ºr andere Dom√§nen
      return `In Bezug auf KI-Entwicklungen sehe ich eine Zukunft, in der spezialisierte, fokussierte L√∂sungen neben den gro√üen generalistischen Modellen bestehen k√∂nnen. 

Insight Synergy kann sich durch Fokussierung auf spezifische Anwendungsgebiete und durch die Integration von Fachwissen differenzieren, anstatt direkt mit den gro√üen Tech-Unternehmen zu konkurrieren.`;
    }
    
    // Wirtschaft und Markt
    if (topic.toLowerCase().includes('wirtschaft') || 
        topic.toLowerCase().includes('markt') || 
        topic.toLowerCase().includes('finan') ||
        topic.toLowerCase().includes('gewinnen') ||
        topic.toLowerCase().includes('wettbewerb') ||
        topic.toLowerCase().includes('konkurrenz')) {
      
      if (expert.domain === 'Wirtschaft') {
        return `Der KI-Markt entwickelt sich zu einem Oligopol, wo einige wenige gro√üe Akteure dominieren. Dennoch gibt es profitable Nischen f√ºr spezialisierte Anbieter.

Insight Synergy sollte eine klar definierte Marktposition entwickeln, basierend auf einzigartigen St√§rken. Eine Differenzierungsstrategie ist essenziell - sei es durch Branchenspezialisierung, √ºberlegene Nutzerfreundlichkeit oder innovative Gesch√§ftsmodelle wie KI-as-a-Service.`;
      }
      
      if (expert.domain.includes('Tech')) {
        return `Technologisch betrachtet liegt die Zukunft in spezialisierter KI, die f√ºr bestimmte Aufgaben optimiert ist. Die gro√üen generalistischen Modelle werden weiterhin von Tech-Giganten dominiert werden.

Insight Synergy sollte auf technologische Differenzierung setzen - etwa durch effizientere Algorithmen, innovative Architekturans√§tze oder verbesserte Datennutzung. Die Kombination von Open-Source-Grundlagen mit propriet√§ren Verbesserungen k√∂nnte ein vielversprechender Ansatz sein.`;
      }
      
      if (expert.domain.includes('Ethik')) {
        return `In einer zunehmend werteorientierten Wirtschaft wird ethisches Handeln zum Wettbewerbsvorteil. Viele Nutzer und Unternehmen suchen nach vertrauensw√ºrdigen KI-L√∂sungen.

Insight Synergy k√∂nnte eine Vorreiterrolle bei ethischer KI einnehmen, mit transparenten Prozessen, fairem Datenumgang und verantwortungsvoller Anwendungsentwicklung. Dies k√∂nnte besonders in regulierten M√§rkten wie Gesundheitswesen oder Finanzen ein entscheidender Vorteil sein.`;
      }
      
      // Default f√ºr andere Dom√§nen
      return `Aus wirtschaftlicher Perspektive sehe ich Chancen f√ºr Insight Synergy in der gezielten Marktpositionierung und Differenzierung. 

W√§hrend die gro√üen Tech-Unternehmen um Marktanteile im Massenmarkt k√§mpfen, kann sich Insight Synergy durch Spezialisierung, √ºberlegenes Branchen-Know-how und ma√ügeschneiderte L√∂sungen absetzen.`;
    }
    
    // Default-Antwort, wenn kein spezifisches Thema erkannt wurde
    return `In Bezug auf die aktuelle und zuk√ºnftige Entwicklung im KI-Bereich sehe ich sowohl Herausforderungen als auch Chancen f√ºr Unternehmen wie Insight Synergy.

Die gro√üen Technologieunternehmen werden weiterhin dominieren, aber es entstehen zunehmend Nischen und Spezialm√§rkte, in denen kleinere, agile Unternehmen erfolgreich sein k√∂nnen. Durch Fokussierung auf spezifische Anwendungsbereiche, √ºberlegene Benutzerfreundlichkeit oder ethische Aspekte kann Insight Synergy einen eigenen Weg finden.`;
  };

  // UI-Rendering
  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        Erweiterte Experten-Debatte
      </Typography>
      <Typography variant="body1" paragraph>
        Erleben Sie eine dynamische Diskussion zwischen verschiedenen KI-Experten mit Echtzeit-Faktenpr√ºfung und adaptiver Gespr√§chsf√ºhrung.
      </Typography>
      
      {!isConnected && (
        <Alert severity="warning" sx={{ mb: 3 }}>
          Sie sind offline. Die Experten-Debatte ist nur online verf√ºgbar.
        </Alert>
      )}
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {/* Tabs f√ºr verschiedene Ansichten */}
      <Tabs
        value={activeTab}
        onChange={(e, newValue) => setActiveTab(newValue)}
        sx={{ mb: 3, borderBottom: 1, borderColor: 'divider' }}
      >
        <Tab label="Debatte vorbereiten" disabled={messages.length > 0} />
        <Tab label="Experten-Diskussion" disabled={selectedExperts.length < 2 && messages.length === 0} />
        <Tab label="Einsichten & Ergebnisse" disabled={insights.length === 0} />
      </Tabs>
      
      {/* Tab 1: Debatte vorbereiten */}
      {activeTab === 0 && (
        <>
          <Paper sx={{ p: 3, mb: 4 }}>
            <Typography variant="h6" gutterBottom>Thema definieren</Typography>
            <TextField
              fullWidth
              label="Debattenthema"
              variant="outlined"
              value={topic}
              onChange={(e) => setTopic(e.target.value)}
              placeholder="z.B. Ethische Implikationen von KI in der Medizin"
              disabled={isGeneratingDebate || !isConnected}
              sx={{ mb: 2 }}
            />
            
            <TextField
              fullWidth
              label="Kontext (optional)"
              variant="outlined"
              multiline
              rows={2}
              value={context}
              onChange={(e) => setContext(e.target.value)}
              placeholder="Zus√§tzlicher Kontext oder spezifische Aspekte, die ber√ºcksichtigt werden sollen"
              disabled={isGeneratingDebate || !isConnected}
              sx={{ mb: 2 }}
            />
            
            <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
              <Button
                variant="outlined"
                onClick={suggestExperts}
                disabled={!topic || topic.length < 5 || !isConnected}
                startIcon={<ScienceIcon />}
              >
                Passende Experten vorschlagen
              </Button>
              
              <Button
                variant="outlined"
                onClick={generateNewExpert}
                disabled={!topic || topic.length < 5 || !isConnected}
                startIcon={<PersonIcon />}
              >
                Neuen Experten generieren
              </Button>
            </Box>
            
            {selectedExperts.length > 0 && (
              <Box sx={{ mb: 2 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Ausgew√§hlte Experten:
                </Typography>
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                  {selectedExperts.map(expert => (
                    <Chip
                      key={expert.id}
                      label={expert.name}
                      variant="outlined"
                      avatar={<Avatar>{expert.avatar || expert.name.charAt(0)}</Avatar>}
                      onDelete={() => toggleExpertSelection(expert)}
                      color="primary"
                    />
                  ))}
                </Box>
              </Box>
            )}
            
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 2 }}>
              <Button
                variant="contained"
                disabled={isGeneratingDebate || !isConnected || topic.length < 5 || selectedExperts.length < 2}
                onClick={startDebate}
                startIcon={isGeneratingDebate ? <CircularProgress size={20} color="inherit" /> : <ForumIcon />}
              >
                {isGeneratingDebate ? 'Generiere Debatte...' : 'Debatte starten'}
              </Button>
              
              <FormControlLabel
                control={
                  <Switch 
                    checked={factCheckingEnabled}
                    onChange={(e) => setFactCheckingEnabled(e.target.checked)}
                  />
                }
                label="Automatischer Faktencheck"
              />
            </Box>
          </Paper>
          
          <Typography variant="h6" gutterBottom>Verf√ºgbare Experten</Typography>
          
          {isLoadingExperts ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            <Grid container spacing={2}>
              {experts.length > 0 ? (
                experts.map(expert => (
                  <Grid item xs={12} sm={6} key={expert.id}>
                    <Card 
                      sx={{ 
                        mb: 2, 
                        border: isExpertSelected(expert.id) ? 2 : 0, 
                        borderColor: 'primary.main',
                        transition: 'all 0.2s ease',
                        '&:hover': {
                          boxShadow: 3
                        }
                      }}
                    >
                      <CardHeader
                        avatar={
                          <Avatar sx={{ bgcolor: isExpertSelected(expert.id) ? 'primary.main' : 'grey.400' }}>
                            {expert.avatar || expert.name.charAt(0)}
                          </Avatar>
                        }
                        action={
                          <Tooltip title={isExpertSelected(expert.id) ? 'Experte entfernen' : 'Experte hinzuf√ºgen'}>
                            <IconButton 
                              onClick={() => toggleExpertSelection(expert)}
                              color={isExpertSelected(expert.id) ? 'primary' : 'default'}
                            >
                              {isExpertSelected(expert.id) ? <RemoveIcon /> : <AddIcon />}
                            </IconButton>
                          </Tooltip>
                        }
                        title={
                          <Box display="flex" alignItems="center">
                            {expert.name}
                            {expert.validatedCredentials && (
                              <VerifiedUserIcon 
                                fontSize="small" 
                                color="primary" 
                                sx={{ ml: 1 }} 
                              />
                            )}
                          </Box>
                        }
                        subheader={`${expert.domain} | ${expert.specialty}`}
                      />
                      <CardContent>
                        <Typography variant="body2" paragraph>
                          {expert.background}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          <strong>Perspektive:</strong> {expert.perspective}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                ))
              ) : (
                <Grid item xs={12}>
                  <Alert severity="info">
                    Keine Experten gefunden. Bitte versuchen Sie es mit einem anderen Thema oder generieren Sie einen neuen Experten.
                  </Alert>
                </Grid>
              )}
            </Grid>
          )}
        </>
      )}
      
      {/* Tab 2: Experten-Diskussion */}
      {activeTab === 1 && (
        <Grid container spacing={3}>
          {/* Linke Seite: Debatte */}
          <Grid item xs={12} md={8}>
            <Paper elevation={1} sx={{ p: 3, mb: 4 }}>
              <Typography variant="h6" gutterBottom>
                Debatte: {debateTargets?.topic || topic}
              </Typography>
              
              {/* Chat-Bereich */}
              <Box 
                ref={chatContainerRef}
                sx={{ 
                  height: '500px', 
                  overflowY: 'auto', 
                  border: '1px solid #eee', 
                  borderRadius: 1,
                  p: 2,
                  mb: 2,
                  position: 'relative'
                }}
              >
                {messages.length === 0 ? (
                  <Box sx={{ 
                    display: 'flex', 
                    flexDirection: 'column', 
                    justifyContent: 'center', 
                    alignItems: 'center',
                    height: '100%' 
                  }}>
                    <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
                      Die Debatte wurde noch nicht gestartet.
                    </Typography>
                    <Button 
                      variant="contained" 
                      onClick={() => setActiveTab(0)}
                      startIcon={<ArrowForwardIcon />}
                    >
                      Debatte vorbereiten
                    </Button>
                  </Box>
                ) : (
                  <>
                    {/* Steuerelemente f√ºr Chat-Funktionen */}
                    <Box sx={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center', 
                      mb: 2,
                      px: 1,
                      py: 0.5,
                      borderRadius: 1,
                      bgcolor: 'rgba(0, 0, 0, 0.03)'
                    }}>
                      {/* Pause/Fortsetzen-Button */}
                      <Tooltip title={isPaused ? "Diskussion fortsetzen" : "Diskussion pausieren"}>
                        <Button
                          size="small"
                          variant="outlined"
                          color={isPaused ? "primary" : "secondary"}
                          onClick={() => setIsPaused(!isPaused)}
                          startIcon={isPaused ? <PlayArrowIcon /> : <PauseIcon />}
                        >
                          {isPaused ? "Fortsetzen" : "Pausieren"}
                        </Button>
                      </Tooltip>
                      
                      {/* Auto-Scroll-Toggle */}
                      <FormControlLabel
                        control={
                          <Switch 
                            checked={autoScroll}
                            onChange={(e) => setAutoScroll(e.target.checked)}
                            size="small"
                            color="primary"
                          />
                        }
                        label={
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body2">Auto-Scroll</Typography>
                            {autoScroll && <CheckIcon fontSize="small" color="success" sx={{ ml: 0.5 }} />}
                          </Box>
                        }
                      />
                    </Box>
                    
                    {messages.map((message) => (
                      <Box key={message.id} sx={{ mb: 3 }}>
                        <Box sx={{ 
                          display: 'flex', 
                          alignItems: 'flex-start',
                          backgroundColor: 
                            message.expertId === 'user' ? 'rgba(0, 0, 0, 0.04)' : 
                            message.expertId === 'system' ? 'rgba(25, 118, 210, 0.08)' : 
                            'transparent',
                          p: 1.5,
                          borderRadius: 2
                        }}>
                          <Avatar sx={{ mr: 2 }}>
                            {message.avatar}
                          </Avatar>
                          <Box sx={{ flexGrow: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                              <Typography variant="subtitle2">
                                {message.expertName}
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                {new Date(message.timestamp).toLocaleTimeString()}
                              </Typography>
                            </Box>
                            <Typography variant="body1" sx={{ my: 1 }}>
                              {message.content}
                            </Typography>
                            
                            {/* Referenzen anzeigen */}
                            {message.references && message.references.length > 0 && (
                              <Box sx={{ mt: 1 }}>
                                <Typography variant="caption" display="block" color="text.secondary">
                                  Referenzen:
                                </Typography>
                                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 0.5 }}>
                                  {message.references.map((ref, idx) => (
                                    <Chip 
                                      key={idx} 
                                      label={ref} 
                                      size="small" 
                                      variant="outlined" 
                                      color="info" 
                                    />
                                  ))}
                                </Box>
                              </Box>
                            )}
                            
                            {/* Faktencheck-Ergebnisse */}
                            {message.factChecked && message.factCheckResult && (
                              <Accordion 
                                sx={{ mt: 1, '&:before': { display: 'none' } }} 
                                disableGutters
                              >
                                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                    <FactCheckIcon 
                                      fontSize="small" 
                                      color={message.factCheckResult.isFactual ? "success" : "error"} 
                                      sx={{ mr: 1 }} 
                                    />
                                    <Typography variant="caption">
                                      {message.factCheckResult.isFactual 
                                        ? `Faktengepr√ºft (${(message.factCheckResult.confidence * 100).toFixed(0)}% Konfidenz)` 
                                        : "Faktenprobleme gefunden"}
                                    </Typography>
                                  </Box>
                                </AccordionSummary>
                                <AccordionDetails>
                                  {message.factCheckResult.isFactual ? (
                                    <Typography variant="body2" color="success.main">
                                      Die Aussagen wurden als faktisch korrekt bewertet.
                                    </Typography>
                                  ) : (
                                    <>
                                      <Typography variant="body2" color="error.main" gutterBottom>
                                        Es wurden m√∂gliche faktische Ungenauigkeiten identifiziert:
                                      </Typography>
                                      <List dense disablePadding>
                                        {message.factCheckResult.corrections?.map((correction, idx) => (
                                          <ListItem key={idx} sx={{ pl: 0 }}>
                                            <ListItemText primary={correction} />
                                          </ListItem>
                                        ))}
                                      </List>
                                    </>
                                  )}
                                  
                                  {message.factCheckResult.sources && (
                                    <Box sx={{ mt: 1 }}>
                                      <Typography variant="caption" display="block">
                                        Quellen:
                                      </Typography>
                                      <List dense disablePadding>
                                        {message.factCheckResult.sources.map((source, idx) => (
                                          <ListItem key={idx} sx={{ pl: 0 }}>
                                            <ListItemText 
                                              primary={source.title} 
                                              secondary={`Zuverl√§ssigkeit: ${(source.reliability || 0.5) * 100}%`} 
                                            />
                                          </ListItem>
                                        ))}
                                      </List>
                                    </Box>
                                  )}
                                </AccordionDetails>
                              </Accordion>
                            )}
                          </Box>
                        </Box>
                      </Box>
                    ))}
                    <div ref={messagesEndRef} />
                    
                    {/* Scroll-Button, wenn nicht am Ende */}
                    {showScrollButton && (
                      <Box 
                        sx={{ 
                          position: 'absolute', 
                          bottom: 20, 
                          right: 20, 
                          zIndex: 10 
                        }}
                      >
                        <Tooltip title="Zum Ende scrollen">
                          <Button
                            variant="contained"
                            color="primary"
                            size="small"
                            onClick={scrollToBottom}
                            startIcon={<ArrowDownwardIcon />}
                            sx={{ borderRadius: '50%', minWidth: 'auto', p: 1 }}
                          >
                            {newMessageCount > 0 ? newMessageCount : ''}
                          </Button>
                        </Tooltip>
                      </Box>
                    )}
                  </>
                )}
              </Box>
              
              {/* Nachrichteneingabe */}
              {messages.length > 0 && (
                <>
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Stellen Sie eine Frage oder lenken Sie die Diskussion..."
                      value={userMessage}
                      onChange={(e) => setUserMessage(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                          e.preventDefault();
                          sendUserMessage();
                        }
                      }}
                      multiline
                      maxRows={3}
                      variant="outlined"
                      size="small"
                    />
                    <Button 
                      variant="contained" 
                      color="primary"
                      onClick={sendUserMessage}
                      disabled={!userMessage.trim()}
                    >
                      <SendIcon />
                    </Button>
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                    <Button 
                      variant="outlined" 
                      color="error"
                      onClick={stopDebate}
                    >
                      Debatte beenden
                    </Button>
                    
                    <Button 
                      variant="outlined"
                      onClick={resetDebate}
                      startIcon={<RefreshIcon />}
                    >
                      Neue Debatte starten
                    </Button>
                  </Box>
                </>
              )}
            </Paper>
          </Grid>
          
          {/* Rechte Seite: Zielsetzung und Einsichten */}
          <Grid item xs={12} md={4}>
            {/* Debattenziele */}
            {debateTargets && showTargets && (
              <Paper sx={{ p: 2, mb: 3 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="h6">Debattenziele</Typography>
                  <IconButton size="small" onClick={() => setShowTargets(false)}>
                    <RemoveIcon />
                  </IconButton>
                </Box>
                <List dense>
                  {debateTargets.goals.map((goal, index) => (
                    <ListItem key={index}>
                      <ListItemIcon sx={{ minWidth: 30 }}>
                        {debateTargets.completedGoals.includes(goal) ? (
                          <CheckCircleIcon color="success" fontSize="small" />
                        ) : (
                          <CircularProgress size={16} variant="determinate" value={30} />
                        )}
                      </ListItemIcon>
                      <ListItemText 
                        primary={goal} 
                        sx={{ 
                          textDecoration: debateTargets.completedGoals.includes(goal) ? 'line-through' : 'none',
                          color: debateTargets.completedGoals.includes(goal) ? 'text.secondary' : 'text.primary' 
                        }}
                      />
                    </ListItem>
                  ))}
                </List>
                {debateTargets.completedGoals.length > 0 && (
                  <LinearProgress 
                    variant="determinate" 
                    value={(debateTargets.completedGoals.length / debateTargets.goals.length) * 100} 
                    sx={{ mt: 2 }}
                  />
                )}
              </Paper>
            )}
            
            {/* Cognitive Loop Analyse */}
            {cognitiveAnalysis && (
              <Paper sx={{ p: 2, mb: 3 }}>
                <Typography variant="h6" gutterBottom>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <PsychologyIcon sx={{ mr: 1 }} />
                    Cognitive Loop Analyse
                  </Box>
                </Typography>
                <List dense>
                  {cognitiveAnalysis.patternDetected && (
                    <ListItem>
                      <ListItemText 
                        primary="Erkanntes Denkmuster" 
                        secondary={cognitiveAnalysis.patternDetected} 
                      />
                    </ListItem>
                  )}
                  {cognitiveAnalysis.biasDetected && (
                    <ListItem>
                      <ListItemText 
                        primary="M√∂gliche Denkverzerrung" 
                        secondary={cognitiveAnalysis.biasDetected}
                        secondaryTypographyProps={{ color: 'warning.main' }}
                      />
                    </ListItem>
                  )}
                  {cognitiveAnalysis.adaptedResponseStyle && (
                    <ListItem>
                      <ListItemText 
                        primary="Angepasster Antwortstil" 
                        secondary={cognitiveAnalysis.adaptedResponseStyle} 
                      />
                    </ListItem>
                  )}
                </List>
              </Paper>
            )}
            
            {/* Einsichten */}
            <Paper sx={{ p: 2 }}>
              <Typography variant="h6" gutterBottom>
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <LightbulbIcon sx={{ mr: 1 }} />
                  Einsichten
                </Box>
              </Typography>
              
              {insights.length === 0 ? (
                <Typography variant="body2" color="text.secondary">
                  Im Laufe der Debatte werden hier wichtige Erkenntnisse erscheinen.
                </Typography>
              ) : (
                <List>
                  {insights.map((insight) => (
                    <ListItem key={insight.id} sx={{ display: 'block', py: 1 }}>
                      <Typography variant="subtitle2">{insight.title}</Typography>
                      <Typography variant="body2" paragraph>
                        {insight.description}
                      </Typography>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                          {insight.tags?.slice(0, 2).map((tag, idx) => (
                            <Chip 
                              key={idx} 
                              label={tag} 
                              size="small" 
                              variant="outlined" 
                            />
                          ))}
                        </Box>
                        <Typography variant="caption">
                          {`${(insight.confidence * 100).toFixed(0)}% Konfidenz`}
                        </Typography>
                      </Box>
                      <Divider sx={{ mt: 1 }} />
                    </ListItem>
                  ))}
                </List>
              )}
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 3: Einsichten & Ergebnisse */}
      {activeTab === 2 && (
        <Paper sx={{ p: 3 }}>
          <Typography variant="h6" gutterBottom>
            Zusammenfassung der Debatte: {debateTargets?.topic || topic}
          </Typography>
          
          {insights.length === 0 ? (
            <Alert severity="info">
              Es wurden noch keine ausreichenden Erkenntnisse aus der Debatte gesammelt.
            </Alert>
          ) : (
            <>
              <Typography variant="subtitle1" gutterBottom sx={{ mt: 3 }}>
                Haupterkenntnisse
              </Typography>
              
              <Grid container spacing={2}>
                {insights.map((insight) => (
                  <Grid item xs={12} md={4} key={insight.id}>
                    <Card elevation={1}>
                      <CardHeader
                        title={insight.title}
                        subheader={`Vorgeschlagen von ${insight.expert}`}
                      />
                      <CardContent>
                        <Typography variant="body2" paragraph>
                          {insight.description}
                        </Typography>
                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                          {insight.tags?.map((tag, idx) => (
                            <Chip 
                              key={idx} 
                              label={tag} 
                              size="small" 
                              variant="outlined" 
                            />
                          ))}
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              
              <Box sx={{ display: 'flex', gap: 2, mt: 3 }}>
                <Button variant="contained" startIcon={<SettingsIcon />}>
                  Exportieren
                </Button>
                <Button variant="outlined" onClick={() => setActiveTab(1)}>
                  Zur√ºck zur Debatte
                </Button>
              </Box>
            </>
          )}
        </Paper>
      )}
      
      <Typography variant="body2" color="text.secondary" sx={{ mt: 4 }}>
        Powered by Cognitive Loop AI
      </Typography>
    </Box>
  );
};

export default LiveExpertDebatePanel; 
